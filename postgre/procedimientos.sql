CREATE OR REPLACE FUNCTION INSERTAR_USUARIO(
    RUT_U IN USUARIO.RUT%TYPE,
    NOMBRES_U IN USUARIO.NOMBRES%TYPE,
    APELLIDOS_U IN USUARIO.APELLIDOS%TYPE,
    CORREO_U IN USUARIO.CORREO%TYPE,
    PASS_U IN USUARIO.PASS%TYPE,
    DIRECCION_U IN USUARIO.DIRECCION%TYPE,
    CELULAR_U IN USUARIO.CELULAR%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$
DECLARE
    L_SAL VARCHAR(30) := 'CONSTRUOK-PIPEMAX-1994';
BEGIN
    IF(LENGTH(CAST (RUT_U AS VARCHAR))<10) THEN
        IF(VALIDACION(RUT_U)=TRUE) THEN
            IF(CHECKUSER(RUT_U)=TRUE) THEN
		BOOL := 'FALSE';
		MESSAGE := 'EL USUARIO CON RUT: '||RUT_U||' QUE INTENTA INGRESAR YA EXISTE';
		RETURN;
	    ELSE
		LOCK TABLE USUARIO IN ROW EXCLUSIVE MODE;
		INSERT INTO USUARIO VALUES(RUT_U,NOMBRES_U,APELLIDOS_U,CORREO_U,'CLIENTE',CRYPT(PASS_U, L_SAL),0,DIRECCION_U,CELULAR_U);
		BOOL := 'TRUE';
		MESSAGE := 'EL USUARIO SE HA INGRESADO EXITOSAMENTE';
		RETURN;
	    END IF;
	ELSE
	    BOOL := 'FALSE';
	    MESSAGE := 'EL RUT: '||RUT_U||' NO ES UN RUT VÁLIDO';
            RETURN;
	END IF;
    ELSE
	BOOL := 'FALSE';
	MESSAGE := 'EL RUT INGRESADO ES MUY LARGO, EXCEDE LOS 10 CARACTERES';
	RETURN;
    END IF;
    EXCEPTION           
	WHEN data_exception THEN
	    BOOL := 'FALSE';
	    MESSAGE := 'HA OCURRIDO UN ERROR DE CONVERSION A NIVEL DE BASE DE DATOS';
            RETURN;
	WHEN unique_violation THEN
	    BOOL := 'FALSE';
	    MESSAGE := 'EL USUARIO CON RUT: '||RUT_U||' QUE INTENTA INGRESAR YA EXISTE';
            RETURN;
	WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
	    MESSAGE := 'NO TIENE PRIVILEGIOS PARA INGRESAR USUARIOS';
            RETURN;
	WHEN OTHERS THEN
	    BOOL := 'FALSE';
	    MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION ELIMINAR_USUARIO(
    RUT_U IN USUARIO.RUT%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$
DECLARE
    NOMBRE_USER VARCHAR(100);
BEGIN
    IF(CHECKUSER(RUT_U)=TRUE) THEN
        SELECT CONCAT(CONCAT(NOMBRES,' '),APELLIDOS) INTO NOMBRE_USER FROM USUARIO WHERE RUT = RUT_U;
        LOCK TABLE USUARIO IN ROW EXCLUSIVE MODE;
        DELETE FROM USUARIO WHERE RUT=RUT_U;
        BOOL := 'TRUE';
        MESSAGE := 'EL USUARIO: '||NOMBRE_USER||' FUE ELIMINADO EXITOSAMENTE';
    ELSE
        BOOL := 'FALSE';
	MESSAGE := 'EL USUARIO INGRESADO NO EXISTE';
    END IF;
    RETURN;
    EXCEPTION
	WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
	    MESSAGE := 'NO TIENE PRIVILEGIOS PARA ELIMINAR USUARIOS';
            RETURN;
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
	    RETURN;
END;
$$ LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION ACTUALIZAR_USER(
    RUT_A IN USUARIO.RUT%TYPE,
    NOMBRES_A IN USUARIO.NOMBRES%TYPE,
    APELLIDOS_A IN USUARIO.APELLIDOS%TYPE,
    CORREO_A IN USUARIO.CORREO%TYPE,
    DIRECCION_U IN USUARIO.DIRECCION%TYPE,
    CELULAR_U IN USUARIO.CELULAR%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$
DECLARE
    NOMBRE_USER VARCHAR(100);
BEGIN
    IF(CHECKUSER(RUT_A)=TRUE) THEN
        SELECT CONCAT(CONCAT(NOMBRES,' '),APELLIDOS) INTO NOMBRE_USER FROM USUARIO WHERE RUT = RUT_A;
        LOCK TABLE USUARIO IN ROW EXCLUSIVE MODE;
        UPDATE USUARIO
        SET NOMBRES=NOMBRES_A,APELLIDOS=APELLIDOS_A,CORREO=CORREO_A,DIRECCION=DIRECCION_U,CELULAR=CELULAR_U
        WHERE RUT=RUT_A;
        BOOL := 'TRUE';
        MESSAGE := 'EL USUARIO: '||NOMBRE_USER||' HA SIDO MODIFICADO EXITOSAMENTE';
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'EL USUARIO QUE INTENTA MODIFICAR NO EXISTE';
    END IF;
    RETURN;
    EXCEPTION
	WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
	    MESSAGE := 'NO TIENE PRIVILEGIOS PARA MODIFICAR USUARIOS';
            RETURN;
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;

select bool,message from actualizar_password_user(123123123,'aaaaaaaa');
CREATE OR REPLACE FUNCTION ACTUALIZAR_PASSWORD_USER(
    RUT_U IN USUARIO.RUT%TYPE,
    PASS_U IN USUARIO.PASS%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$
DECLARE
    NOMBRE_USER VARCHAR(100);
    L_SAL VARCHAR(30) := 'CONSTRUOK-PIPEMAX-1994';
BEGIN
    IF (CHECKUSER(RUT_U)=TRUE)  THEN
        SELECT CONCAT(CONCAT(NOMBRES,' '),APELLIDOS) INTO NOMBRE_USER FROM USUARIO WHERE RUT = RUT_U;
        LOCK TABLE USUARIO IN ROW EXCLUSIVE MODE;
        UPDATE USUARIO
        SET PASS = CRYPT(UPPER(PASS_U), L_SAL)
        WHERE RUT=RUT_U;
        BOOL := 'TRUE';
        MESSAGE := 'LA CONTRASEÑA DEL USUARIO: '||NOMBRE_USER||' SE HA MODIFICADO EXITOSAMENTE';
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'LA CONTRASEÑA NO SE PUDO MODIFICAR YA QUE EL USUARIO NO EXISTE';
    END IF;
    RETURN;
    EXCEPTION
	WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
	    MESSAGE := 'NO TIENE PRIVILEGIOS PARA MODIFICAR LA CONTRASEÑA DE ESTE USUARIO';
            RETURN;
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION NUEVA_HERRAMIENTA(
    CODIGO IN HERRAMIENTA.COD_HERRAMIENTA%TYPE,
    NOMBRE_H IN HERRAMIENTA.NOMBRE%TYPE,
    DESCRIPCION_H IN HERRAMIENTA.DESCRIPCION%TYPE,
    URL_FOTO_H IN HERRAMIENTA.URL_FOTO%TYPE,
    CATEGORIA_ID_H IN HERRAMIENTA.COD_CATEGORIA%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR
)
RETURNS RECORD AS $$
DECLARE
BEGIN
    IF CHECKHERRAMIENTA(CODIGO)=FALSE THEN
        LOCK TABLE HERRAMIENTA IN ROW EXCLUSIVE MODE;
        INSERT INTO HERRAMIENTA VALUES(CODIGO,NOMBRE_H,DESCRIPCION_H,URL_FOTO_H,CATEGORIA_ID_H);
        BOOL := 'TRUE';
        MESSAGE := 'SE HA REGISTRADO UNA NUEVA HERRAMIENTA CON CÓDIGO: '||CODIGO;
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'LA HERRAMIENTA QUE INTENTA REGISTRAR YA EXISTE, MODIFIQUE EL STOCK EN LA HERRAMIENTA CÓDIGO: '||CODIGO;
    END IF;
    RETURN;
    EXCEPTION
        WHEN data_exception THEN
            BOOL := 'FALSE';
            MESSAGE := 'HA OCURRIDO UN ERROR DE CONVERSIÓN A NIVEL DE BASE DE DATOS';
            RETURN;
        WHEN unique_violation THEN
            BOOL := 'FALSE';
            MESSAGE := 'LA HERRAMIENTA CON CÓDIGO: '||CODIGO||' YA EXISTE EN LA BASE DE DATOS';
            RETURN;
	WHEN foreign_key_violation THEN
	    BOOL := 'FALSE';
            MESSAGE := 'LA CATEGORÍA SELECCIONADA NO EXISTE';
            RETURN;
	WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
	    MESSAGE := 'NO TIENE PRIVILEGIOS PARA REGISTRAR HERRAMIENTAS';
            RETURN;
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM; 
            RETURN;
END;
$$ LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION VINCULAR_HERRAMIENTA_SUCURSAL(
    CODIGO IN SUCURSAL_HERRAMIENTA.COD_HERRAMIENTA%TYPE, -- codigo herramienta
    CODIGO_S IN SUCURSAL_HERRAMIENTA.COD_SUCURSAL%TYPE,  -- codigo sucursal
    PRECIO_H IN SUCURSAL_HERRAMIENTA.PRECIO%TYPE,        -- precio herramienta
    STOCK_H IN SUCURSAL_HERRAMIENTA.STOCK%TYPE,          -- stock herramienta
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE
    NOMBRE_S VARCHAR(100);
    NOMBRE_H VARCHAR(100);
BEGIN
    IF (CHECKHERRAMIENTA(CODIGO)=TRUE AND CHECKSUCURSAL(CODIGO_S)=TRUE) THEN
        SELECT NOMBRE INTO NOMBRE_S FROM SUCURSAL WHERE COD_SUCURSAL = CODIGO_S;
        SELECT NOMBRE INTO NOMBRE_H FROM HERRAMIENTA WHERE COD_HERRAMIENTA = CODIGO;
        IF(VERIFICA_HERRAMIENTA_SUCURSAL(CODIGO,CODIGO_S)=FALSE) THEN
            LOCK TABLE SUCURSAL_HERRAMIENTA IN ROW EXCLUSIVE MODE;
            INSERT INTO SUCURSAL_HERRAMIENTA VALUES (CODIGO,CODIGO_S,STOCK_H,PRECIO_H);
            
            BOOL := 'TRUE';
            MESSAGE := 'LA VINCULACIÓN DE LA HERRAMIENTA: "'||NOMBRE_H||'" CON LA SUCURSAL:  "'||NOMBRE_S||'" SE REALIZÓ CORRECTAMENTE';
        ELSE
            BOOL := 'FALSE';
            MESSAGE := 'YA EXISTE ESTA HERRAMIENTA VINCULADA A ESTA SUCURSAL, MODIFIQUE STOCK O PRECIO';
        END IF;            
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'EL CÓDIGO DE HERRAMIENTA O LA SUCURSAL SELECCIONADA NO EXISTE EN LA BASE DE DATOS';
    END IF;
    RETURN;
    EXCEPTION
	WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
            MESSAGE := 'NO TIENE PRIVILEGIOS PARA VINCULAR HERRAMIENTAS';
            RETURN;
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END; 
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION DESVINCULAR_H_SUCURSAL(
    CODIGO IN SUCURSAL_HERRAMIENTA.COD_HERRAMIENTA%TYPE,
    CODIGO_S IN SUCURSAL_HERRAMIENTA.COD_SUCURSAL%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE
    NOMBRE_S VARCHAR(100);
    NOMBRE_H VARCHAR(100);
BEGIN
    IF (CHECKHERRAMIENTA(CODIGO)=TRUE AND CHECKSUCURSAL(CODIGO_S)=TRUE) THEN
        SELECT NOMBRE INTO NOMBRE_S FROM SUCURSAL WHERE COD_SUCURSAL = CODIGO_S;
        SELECT NOMBRE INTO NOMBRE_H FROM HERRAMIENTA WHERE COD_HERRAMIENTA = CODIGO;
        IF(VERIFICA_HERRAMIENTA_SUCURSAL(CODIGO,CODIGO_S)=TRUE) THEN
            LOCK TABLE SUCURSAL_HERRAMIENTA IN ROW EXCLUSIVE MODE;
            DELETE FROM SUCURSAL_HERRAMIENTA WHERE COD_HERRAMIENTA = CODIGO AND COD_SUCURSAL = CODIGO_S;
            
            BOOL := 'TRUE';
            MESSAGE := 'LA HERRAMIENTA: "'||NOMBRE_H||'" SE HA DESVINCULADO DE LA SUCURSAL: "'||NOMBRE_S||'"';
        END IF;            
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'EL CÓDIGO DE HERRAMIENTA O LA SUCURSAL SELECCIONADA NO EXISTE.';
    END IF;
    RETURN;
    EXCEPTION
	WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
	    MESSAGE := 'NO TIENE PRIVILEGIOS PARA DESVINCULAR HERRAMIENTAS';
            RETURN;
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;            
END; 
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION ACTUALIZAR_H_SUCURSAL(
    CODIGO IN SUCURSAL_HERRAMIENTA.COD_HERRAMIENTA%TYPE,
    CODIGO_S IN SUCURSAL_HERRAMIENTA.COD_SUCURSAL%TYPE,
    STOCK_H IN SUCURSAL_HERRAMIENTA.STOCK%TYPE,
    PRECIO_H IN SUCURSAL_HERRAMIENTA.PRECIO%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE
    NOMBRE_H VARCHAR(100);
    NOMBRE_S VARCHAR(100);
BEGIN
    IF(CHECKHERRAMIENTA(CODIGO)=TRUE AND CHECKSUCURSAL(CODIGO_S)=TRUE) THEN
        SELECT NOMBRE INTO NOMBRE_H FROM HERRAMIENTA WHERE COD_HERRAMIENTA = CODIGO;
        SELECT NOMBRE INTO NOMBRE_S FROM SUCURSAL WHERE COD_SUCURSAL = CODIGO_S;
        LOCK TABLE SUCURSAL_HERRAMIENTA IN ROW EXCLUSIVE MODE;
        UPDATE SUCURSAL_HERRAMIENTA 
        SET STOCK = STOCK_H, PRECIO = PRECIO_H
        WHERE COD_HERRAMIENTA = CODIGO AND COD_SUCURSAL = CODIGO_S;        
        BOOL := 'TRUE';
        MESSAGE := 'SE HA ACTUALIZADO EL STOCK Y/O PRECIOS DE LA HERRAMIENTA "'||NOMBRE_H||'" EN LA SUCURSAL "'||NOMBRE_S||'"';
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'LA HERRAMIENTA O SUCURSAL SELECCIONADA NO EXISTEN.';
    END IF;
    RETURN;
    EXCEPTION
	WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
	    MESSAGE := 'NO TIENE PRIVILEGIOS PARA ACTUALIZAR INFORMACIÓN DE LAS HERRAMIENTAS';
            RETURN;
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END; 
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION AUMENTAR_STOCK(
    CODIGO IN SUCURSAL_HERRAMIENTA.COD_HERRAMIENTA%TYPE,
    CANTIDAD IN INT,
    CODIGO_S IN INT,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE
BEGIN
    IF CHECKHERRAMIENTA(CODIGO)=TRUE THEN
        LOCK TABLE SUCURSAL_HERRAMIENTA IN ROW EXCLUSIVE MODE;
        UPDATE SUCURSAL_HERRAMIENTA 
        SET STOCK = (STOCK + CANTIDAD)
        WHERE COD_HERRAMIENTA=CODIGO AND COD_SUCURSAL=CODIGO_S;
        
        BOOL := 'TRUE';
        MESSAGE := 'SE HA INCREMENTADO EL STOCK DE LA HERRAMIENTA CÓDIGO: '||CODIGO||' EN '||CANTIDAD||' UNIDADES';
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'NO SE PUEDE AUMENTAR EL STOCK EN LA HERRAMIENTA CÓDIGO: '||CODIGO||' YA QUE NO EXISTE EN LA BASE DE DATOS';
    END IF;
    RETURN;
    EXCEPTION
	WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
            MESSAGE := 'NO TIENE PRIVILEGIOS PARA AUMENTAR EL STOCK DE LA HERRAMIENTA';
            RETURN;
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION QUITAR_STOCK(
    CODIGO IN SUCURSAL_HERRAMIENTA.COD_HERRAMIENTA%TYPE,
    CANTIDAD IN INT,
    CODIGO_S IN INT,
    FECHA_I IN VARCHAR,
    FECHA_F IN VARCHAR,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE
    STOCK_ACTUAL INT;
BEGIN
    IF(CHECKHERRAMIENTA(CODIGO)=TRUE) THEN
        STOCK_ACTUAL := CHECKSTOCK(CODIGO,CODIGO_S,FECHA_I,FECHA_F);        
        IF(STOCK_ACTUAL-CANTIDAD>=0 AND CANTIDAD>0) THEN
            LOCK TABLE SUCURSAL_HERRAMIENTA IN ROW EXCLUSIVE MODE;
            UPDATE SUCURSAL_HERRAMIENTA
            SET STOCK = (STOCK-CANTIDAD)
            WHERE COD_HERRAMIENTA = CODIGO AND COD_SUCURSAL = CODIGO_S;            
            BOOL := 'TRUE';
            MESSAGE := 'SE HA DECREMENTADO EL STOCK DE LA HERRAMIENTA CÓDIGO: '||CODIGO||' EN '||CANTIDAD||' UNIDADES';
        ELSE
            IF(CANTIDAD=0 OR CANTIDAD<0) THEN
                BOOL := 'FALSE';
                MESSAGE := 'DEBE INGRESAR UNA CANTIDAD MAYOR A CERO';
            ELSE
                BOOL := 'FALSE';
                MESSAGE := 'NO SE PUEDE DECREMENTAR EL STOCK EN '||CANTIDAD|| ' YA QUE EL SERÍA STOCK NEGATIVO';
            END IF;
        END IF;
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'NO SE PUEDE AUMENTAR EL STOCK EN LA HERRAMIENTA CÓDIGO: '||CODIGO||' YA QUE NO EXISTE EN LA BASE DE DATOS';
    END IF;
    RETURN;
    EXCEPTION
	WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
            MESSAGE := 'NO TIENE PRIVILEGIOS PARA DECREMENTAR EL STOCK DE LA HERRAMIENTA';
            RETURN;
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION ELIMINAR_HERRAMIENTA(
    CODIGO IN HERRAMIENTA.COD_HERRAMIENTA%TYPE,    
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE
BEGIN
    IF(CHECKHERRAMIENTA(CODIGO)=TRUE) THEN
        LOCK TABLE HERRAMIENTA IN ROW EXCLUSIVE MODE;
        DELETE FROM HERRAMIENTA WHERE COD_HERRAMIENTA=CODIGO;
        
        BOOL := 'TRUE';
        MESSAGE := 'LA HERRAMIENTA CÓDIGO: '||CODIGO||' HA SIDO ELIMINADA CON ÉXTIO';
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'LA HERRAMIENTA QUE INTENTA ELIMINAR NO EXISTE';
    END IF;
    RETURN;
    EXCEPTION
	WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
            MESSAGE := 'NO TIENE PRIVILEGIOS PARA ELIMINAR LA HERRAMIENTA';
            RETURN;
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END; 
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION ACTUALIZAR_HERRAMIENTA(
    CODIGO IN HERRAMIENTA.COD_HERRAMIENTA%TYPE,
    NOMBRE_H IN HERRAMIENTA.NOMBRE%TYPE,
    DESCRIPCION_H IN HERRAMIENTA.DESCRIPCION%TYPE,
    URL_FOTO_H IN HERRAMIENTA.URL_FOTO%TYPE,
    CATEGORIA_H IN HERRAMIENTA.COD_CATEGORIA%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE 
    NOMBRE_HH VARCHAR(100);
BEGIN
    IF(CHECKHERRAMIENTA(CODIGO)=TRUE) THEN
        SELECT NOMBRE INTO NOMBRE_HH FROM HERRAMIENTA WHERE COD_HERRAMIENTA = CODIGO;
        LOCK TABLE HERRAMIENTA IN ROW EXCLUSIVE MODE;
        UPDATE HERRAMIENTA
        SET NOMBRE=NOMBRE_H,DESCRIPCION=DESCRIPCION_H,URL_FOTO=URL_FOTO_H,COD_CATEGORIA=CATEGORIA_H
        WHERE COD_HERRAMIENTA=CODIGO;        
        BOOL := 'TRUE';
        MESSAGE := 'SE HA ACTUALIZADO EXITOSAMENTE LA HERRAMIENTA CÓDIGO: '||NOMBRE_HH;
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'NO SE PUEDE ACTUALIZAR LA HERRAMIENTA YA QUE NO EXISTE EN LA BASE DE DATOS';
    END IF;
    RETURN;
    EXCEPTION
	WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
            MESSAGE := 'NO TIENE PRIVILEGIOS PARA ACTUALIZAR LA HERRAMIENTA';
            RETURN;
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION NUEVA_SUCURSAL(
    NOMBRE_S IN SUCURSAL.NOMBRE%TYPE,
    DIRECCION_S IN SUCURSAL.DIRECCION%TYPE,
    TELEFONO_S IN SUCURSAL.TELEFONO%TYPE,
    URL_FOTO_S IN SUCURSAL.URL_FOTO%TYPE,
    COD_EMPRESA_S IN SUCURSAL.COD_EMPRESA%TYPE,
    REGION_S IN SUCURSAL.REGION%TYPE,
    CIUDAD_S IN SUCURSAL.CIUDAD%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE 
BEGIN
    LOCK TABLE SUCURSAL IN ROW EXCLUSIVE MODE;
    INSERT INTO SUCURSAL(COD_SUCURSAL,NOMBRE,DIRECCION,TELEFONO,URL_FOTO,COD_EMPRESA,REGION,CIUDAD) VALUES (NEXTVAL('SUCURSAL_AI'),NOMBRE_S,DIRECCION_S,TELEFONO_S,URL_FOTO_S,COD_EMPRESA_S,REGION_S,CIUDAD_S);
    BOOL := 'TRUE';
    MESSAGE := 'LA SUCURSAL SE HA INGRESADO EXITOSAMENTE';
    RETURN;
    EXCEPTION
	WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
	    MESSAGE := 'NO TIENE PRIVILEGIOS PARA REGISTRAR UNA NUEVA SUCURSAL';
            RETURN;
        WHEN unique_violation THEN
            BOOL := 'FALSE';
            MESSAGE := 'LA SUCURSAL QUE INTENTA INGRESAR YA SE ENCUENTRA REGISTRADA';         
            RETURN;   
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION ELIMINAR_SUCURSAL(
    CODIGO IN SUCURSAL.COD_SUCURSAL%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE
    NOMBRE_SUCURSAL VARCHAR(100);
BEGIN
    IF(CHECKSUCURSAL(CODIGO)=TRUE) THEN
        SELECT NOMBRE INTO NOMBRE_SUCURSAL FROM SUCURSAL WHERE COD_SUCURSAL = CODIGO;
        LOCK TABLE SUCURSAL IN ROW EXCLUSIVE MODE;
        DELETE FROM SUCURSAL WHERE COD_SUCURSAL=CODIGO;
        
        BOOL := 'TRUE';
        MESSAGE := 'LA SUCURSAL: '||NOMBRE_SUCURSAL||' HA SIDO ELIMINADA SATISFACTORIAMENTE';
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'LA SUCURSAL QUE INTENTA ELIMINAR NO EXISTE EN LA BASE DE DATOS';
    END IF;
    RETURN;
    EXCEPTION
	WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
            MESSAGE := 'NO TIENE PRIVILEGIOS PARA ELIMINAR UNA SUCURSAL';
            RETURN;
        WHEN OTHERS THEN
            BOOL:='FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION ACTUALIZAR_SUCURSAL(
    CODIGO IN SUCURSAL.COD_SUCURSAL%TYPE,
    NOMBRE_S IN SUCURSAL.NOMBRE%TYPE,
    DIRECCION_S IN SUCURSAL.DIRECCION%TYPE,
    TELEFONO_S IN SUCURSAL.TELEFONO%TYPE,
    URL_FOTO_S IN SUCURSAL.URL_FOTO%TYPE,
    COD_EMPRESA_S IN SUCURSAL.COD_EMPRESA%TYPE,
    REGION_S IN SUCURSAL.REGION%TYPE,
    CIUDAD_S IN SUCURSAL.CIUDAD%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE
    NOMBRE_SUCURSAL VARCHAR(100);
BEGIN
    IF(CHECKSUCURSAL(CODIGO)=TRUE) THEN
        SELECT NOMBRE INTO NOMBRE_SUCURSAL FROM SUCURSAL WHERE COD_SUCURSAL = CODIGO;
        LOCK TABLE SUCURSAL IN ROW EXCLUSIVE MODE;
        UPDATE SUCURSAL
        SET NOMBRE=NOMBRE_S,DIRECCION=DIRECCION_S,TELEFONO=TELEFONO_S,URL_FOTO=URL_FOTO_S,COD_EMPRESA=COD_EMPRESA_S,REGION=REGION_S,CIUDAD=CIUDAD_S
        WHERE COD_SUCURSAL=CODIGO;        
        BOOL := 'TRUE';
        MESSAGE := 'LA ACTUALIZACIÓN DE LA SUCURSAL: '||NOMBRE_SUCURSAL||' SE HA REALIZADO CON ÉXITO';
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'NO SE PUDO ACTUALIZAR LA SUCURSAL YA QUE NO EXISTE EN LA BASE DE DATOS';
    END IF;
    RETURN;
    EXCEPTION
	WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
            MESSAGE := 'NO TIENE PRIVILEGIOS PARA ACTUALIZAR LA SUCURSAL';
            RETURN;
        WHEN OTHERS THEN    
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION VERIFICARUT(
    RUT_U IN USUARIO.RUT%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE 
BEGIN
    IF(CHECKUSER(RUT_U)=TRUE) THEN
        BOOL := 'TRUE';
        MESSAGE := 'USUARIO VERIFICADO';
    ELSE
        BOOL:='FALSE';
        MESSAGE := 'USUARIO NO ENCONTRADO';
    END IF;
    RETURN;
    EXCEPTION
        WHEN OTHERS THEN
            BOOL := 'ERROR';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION OBTENERPASS(
    RUT_U IN USUARIO.RUT%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE 
    PASS_U VARCHAR(100);
BEGIN
    IF ISNUMERIC(RUT_U) THEN
        PASS_U := GETPASS(RUT_U);
        IF(PASS_U!='FALSE') THEN
            BOOL := 'TRUE';
            MESSAGE := PASS_U;
        ELSE
            BOOL := 'FALSE';
            MESSAGE := 'EL USUARIO NO EXISTE';
        END IF;
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'EL VALOR DEL RUT DEBE SER NUMÉRICO';
    END IF;
    RETURN;
    EXCEPTION
        WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
            MESSAGE := 'NO TIENE PRIVILEGIOS PARA OBTENER LA CONTRASEÑA';
            RETURN;
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION NUEVA_CATEGORIA(
    NOMBRE_C IN CATEGORIA.NOMBRE%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ DECLARE
BEGIN
    LOCK TABLE CATEGORIA IN ROW EXCLUSIVE MODE;
    INSERT INTO CATEGORIA(COD_CATEGORIA,NOMBRE) VALUES (NEXTVAL('CATEGORIA_AI'),NOMBRE_C);    
    BOOL := 'TRUE';
    MESSAGE := 'LA NUEVA CATEGORIA SE HA CREADO EXITOSAMENTE';
    RETURN;
    EXCEPTION
        WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
            MESSAGE := 'NO TIENE PRIVILEGIOS PARA CREAR UNA CATEGORIA';
            RETURN;
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION ELIMINAR_CATEGORIA(
    CODIGO IN CATEGORIA.COD_CATEGORIA%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ DECLARE
BEGIN 
    IF(CHECKCATEGORIA(CODIGO)=TRUE) THEN
        LOCK TABLE CATEGORIA IN ROW EXCLUSIVE MODE;
        DELETE FROM CATEGORIA WHERE COD_CATEGORIA=CODIGO;        
        BOOL := 'TRUE';
        MESSAGE := 'SE HA ELIMINADO LA CATEGORIA EXITOSAMENTE';
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'LA CATEGORIA QUE INTENTA ELIMINAR NO EXISTE';
    END IF;
    RETURN;
    EXCEPTION
        WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
            MESSAGE := 'NO TIENE PRIVILEGIOS PARA ELIMINAR LA CATEGORIA';
            RETURN;
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION ACTUALIZAR_CATEGORIA(
    CODIGO IN CATEGORIA.COD_CATEGORIA%TYPE,
    NOMBRE_C IN CATEGORIA.NOMBRE%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ DECLARE
BEGIN
    IF(CHECKCATEGORIA(CODIGO)=TRUE) THEN
        LOCK TABLE CATEGORIA IN ROW EXCLUSIVE MODE;
        UPDATE CATEGORIA
        SET NOMBRE=NOMBRE_C
        WHERE COD_CATEGORIA=CODIGO;        
        BOOL := 'TRUE';
        MESSAGE := 'LA CATEGORIA CON CÓDIGO: '||CODIGO||' SE HA ACTUALIZADO CORRECTAMENTE';
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'LA CATEGORIA QUE INTENTA ACTUALIZAR NO EXISTE';
    END IF;
    RETURN;
    EXCEPTION
        WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
            MESSAGE := 'NO TIENE PRIVILEGIOS PARA ACTUALIZAR LA CATEGORIA';
            RETURN;
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION AGREGA_CARRITO(
    RUT_U IN USUARIO.RUT%TYPE,
    CODIGO IN SUCURSAL_HERRAMIENTA.COD_HERRAMIENTA%TYPE,
    CODIGO_S IN SUCURSAL_HERRAMIENTA.COD_SUCURSAL%TYPE,
    FECHA_I IN VARCHAR,
    FECHA_F IN VARCHAR,
    CANTIDAD_C IN INT,    
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE
    MAXIMOSTOCK INT;
    CANTIDAD_CARRO INT;
BEGIN    
    IF(CHECKHERRAMIENTA(CODIGO)=TRUE) THEN
        MAXIMOSTOCK := CHECKSTOCK(CODIGO,CODIGO_S,FECHA_I,FECHA_F);    
        IF(CHECKCARRITO(CODIGO,CODIGO_S,RUT_U)=TRUE) THEN
            IF(CANTIDAD_C>0) THEN                
                CANTIDAD_CARRO := CHECK_CANTIDAD_CARRITO(CODIGO,CODIGO_S,RUT_U); 
                IF (CANTIDAD_CARRO<>-1) THEN
                    IF((CANTIDAD_C + CANTIDAD_CARRO)<=MAXIMOSTOCK) THEN
                        LOCK TABLE CARRITO IN ROW EXCLUSIVE MODE;
                        UPDATE CARRITO
                        SET CANTIDAD = CANTIDAD_CARRO + CANTIDAD_C
                        WHERE COD_HERRAMIENTA = CODIGO
                        AND RUT = RUT_U
                        AND COD_SUCURSAL = CODIGO_S;
                        
                        BOOL := 'TRUE';
                        MESSAGE := 'EL CARRITO SE HA ACTUALIZADO CON ÉXITO';
                    ELSE
                        IF(CANTIDAD_CARRO = MAXIMOSTOCK) THEN
                            BOOL := 'FALSE';
                            MESSAGE := 'YA ALCANZÓ EL MÁXIMO STOCK DE NUESTRA HERRAMIENTA EN EL CARRITO';
                        ELSE
                            LOCK TABLE CARRITO IN ROW EXCLUSIVE MODE;
                            UPDATE CARRITO
                            SET CANTIDAD = MAXIMOSTOCK
                            WHERE COD_HERRAMIENTA = CODIGO
                            AND RUT = RUT_U
                            AND COD_SUCURSAL = CODIGO_S;                            
                            BOOL := 'TRUE';
                            MESSAGE := 'EL CARRITO SE HA ACTUALIZADO CON ÉXITO';
                        END IF;
                    END IF;
                ELSE
                    BOOL := 'FALSE';
                    MESSAGE := 'LA HERRAMIENTA QUE SELECCIONÓ NO EXISTE EN LA BASE DE DATOS';
                END IF;
            ELSE
                BOOL := 'FALSE';
                MESSAGE := 'LA CANTIDAD DEL PRODUCTO NO PUEDE SER CERO O NEGATIVA';
            END IF;
        ELSE
            IF(CANTIDAD_C>0) THEN
                IF(CANTIDAD_C > MAXIMOSTOCK) THEN
                    BOOL := 'FALSE';
                    MESSAGE := 'LA CANTIDAD DE PRODUCTOS QUE HA SELECCIONADO EXCEDE EL MÁXIMO';
                ELSE
                    LOCK TABLE CARRITO IN ROW EXCLUSIVE MODE;
                    INSERT INTO CARRITO (COD_HERRAMIENTA,RUT,CANTIDAD,COD_SUCURSAL) VALUES (CODIGO,RUT_U,CANTIDAD_C,CODIGO_S);                    
                    BOOL := 'TRUE';
                    MESSAGE := 'SU CARRITO SE HA ACTUALIZADO CON LOS PRODUCTOS SELECCIONADOS';
                END IF;
            ELSE
                BOOL := 'FALSE';
                MESSAGE := 'LA CANTIDAD DEL PRODUCTO NO PUEDE SER CERO O NEGATIVA';
            END IF;
        END IF;
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'LA HERRAMIENTA QUE SELECCIONÓ NO EXISTE EN LA BASE DE DATOS';
    END IF;
    RETURN;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION VACIAR_CARRITO(
    RUT_U IN USUARIO.RUT%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE
BEGIN
    IF(CHECKUSER(RUT_U)=TRUE) THEN
        LOCK TABLE CARRITO IN ROW EXCLUSIVE MODE;
        DELETE FROM CARRITO WHERE RUT = RUT_U;        
        BOOL := 'TRUE';
        MESSAGE := 'SE HA VACIADO EL CARRITO EXITOSAMENTE';
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'EL CARRITO NO SE PUEDO VACIAR YA QUE EL USUARIO NO EXISTE';
    END IF;
    RETURN;
    EXCEPTION 
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION BORRAR_HERRAMIENTA_CARRITO(
    RUT_U IN CARRITO.RUT%TYPE,
    CODIGO_H IN CARRITO.COD_HERRAMIENTA%TYPE,
    CODIGO_S IN CARRITO.COD_SUCURSAL%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE
BEGIN
    IF(CHECKCARRITO(CODIGO_H,CODIGO_S,RUT_U)=TRUE) THEN
        LOCK TABLE CARRITO IN ROW EXCLUSIVE MODE;
        DELETE FROM CARRITO WHERE COD_HERRAMIENTA = CODIGO_H
        AND COD_SUCURSAL = CODIGO_S
        AND RUT = RUT_U;        
        BOOL := 'TRUE';
        MESSAGE := 'LA HERRAMIENTA SE HA ELIMINADO CON EXITO';
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'LA HERRAMIENTA NO ESTÁ EN EL CARRITO';
    END IF;
    RETURN;
    EXCEPTION
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;
    
CREATE OR REPLACE FUNCTION QUITA_CARRITO(
    RUT_U IN USUARIO.RUT%TYPE,
    CODIGO IN HERRAMIENTA.COD_HERRAMIENTA%TYPE,
    CODIGO_S IN SUCURSAL_HERRAMIENTA.COD_SUCURSAL%TYPE,
    CANTIDAD_C IN INT,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE
    CANTIDAD_CARRITO INT;
BEGIN
    IF(CANTIDAD_C>0) THEN
        CANTIDAD_CARRITO := CHECK_CANTIDAD_CARRITO(CODIGO,CODIGO_S,RUT_U);
        IF (CANTIDAD_CARRITO<>-1) THEN
            IF(CHECKHERRAMIENTA(CODIGO)=TRUE) THEN
                IF(CHECKCARRITO(CODIGO,CODIGO_S,RUT_U)=TRUE) THEN
                    IF((CANTIDAD_CARRITO-CANTIDAD_C)>=0) THEN
                        LOCK TABLE CARRITO IN ROW EXCLUSIVE MODE;
                        UPDATE CARRITO
                        SET CANTIDAD = CANTIDAD_CARRITO - CANTIDAD_C
                        WHERE COD_HERRAMIENTA = CODIGO
                        AND RUT = RUT_U
                        AND COD_SUCURSAL = CODIGO_S;
                        
                        IF(CHECK_CANTIDAD_CARRITO(CODIGO,CODIGO_S,RUT_U)=0) THEN
                            LOCK TABLE CARRITO IN ROW EXCLUSIVE MODE;
                            DELETE FROM CARRITO WHERE COD_HERRAMIENTA = CODIGO
                            AND RUT = RUT_U
                            AND COD_SUCURSAL = CODIGO_S;
                            
                        END IF;
                        BOOL := 'TRUE';
                        MESSAGE := 'EL CARRITO SE HA ACTUALIZADO CON ÉXITO';
                    ELSE
                        BOOL := 'FALSE';
                        MESSAGE := 'LA CANTIDAD INGRESADA SUPERA A LA CANTIDAD DE PRODUCTOS DEL CARRITO';
                    END IF;
                END IF;
            END IF;
        ELSE
            BOOL := 'FALSE';
            MESSAGE := 'UPS! LA HERRAMIENTA SE ELIMINÓ DEL CARRITO';
        END IF;
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'LA CANTIDAD DEL PRODUCTO NO PUEDE SER CERO O NEGATIVA';
    END IF;
    RETURN;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            BOOL := 'FALSE';
            MESSAGE := 'NO SE PUEDE QUITAR LA HERRAMIENTA YA QUE NO ESTÁ EN EL CARRITO';
            RETURN;
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION ARRENDAR(
    F_INICIO IN VARCHAR,
    F_FINAL IN VARCHAR,
    RUT_U IN ARRIENDO.RUT_U%TYPE,
    COD_S IN SUCURSAL.COD_SUCURSAL%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR,
    CODIGO_ARRIENDO OUT INT)
RETURNS RECORD AS $$ 
DECLARE
    VERIFICADOR INT;
    CONTADOR INT;
    ALMACENAJE INT;
    ID_ARRIENDO INT;
    REGISTRO RECORD;
    VERIFICADOR_CURSOR INT := 0;
    VERIFICA_PRODUCTOS CURSOR FOR SELECT COD_HERRAMIENTA,CANTIDAD,COD_SUCURSAL,TOTAL FROM CARRITO 
    WHERE RUT = RUT_U AND COD_SUCURSAL = COD_S;
BEGIN
    IF (CHECK_FECHA_FINAL(TO_DATE(F_INICIO,'DD/MM/YYYY'),TO_DATE(F_FINAL,'DD/MM/YYYY'))) = TRUE THEN
        SELECT COUNT(*) INTO VERIFICADOR FROM CARRITO WHERE RUT = RUT_U AND COD_SUCURSAL = COD_S;   
        CONTADOR := 0;
        FOR REGISTRO IN VERIFICA_PRODUCTOS LOOP        
            VERIFICADOR_CURSOR := 1;
            ALMACENAJE := VERIFICAR_PRODUCTO_VENTA(TO_DATE(F_INICIO,'DD/MM/YYYY'),TO_DATE(F_FINAL,'DD/MM/YYYY'),REGISTRO.COD_SUCURSAL,REGISTRO.COD_HERRAMIENTA);  
            IF REGISTRO.CANTIDAD <= ALMACENAJE THEN
                CONTADOR := CONTADOR + 1;
            END IF;
        END LOOP;
        IF VERIFICADOR_CURSOR=0 THEN
            BOOL := 'FALSE';
            MESSAGE := 'EL CARRITO DE COMPRAS ESTÁ VACÍO';
            CODIGO_ARRIENDO := -1;
            RETURN;
        END IF;
        IF CONTADOR = VERIFICADOR THEN
            ID_ARRIENDO := NEXTVAL('ARRIENDO_AI');
            LOCK TABLE ARRIENDO IN ROW EXCLUSIVE MODE;
            INSERT INTO ARRIENDO VALUES (ID_ARRIENDO,TO_DATE(F_INICIO,'DD/MM/YYYY'),TO_DATE(F_FINAL,'DD/MM/YYYY'),0,RUT_U,COD_S,'ACTIVO',NOW());
            LOCK TABLE DETALLE IN ROW EXCLUSIVE MODE;
            FOR REGISTRO IN VERIFICA_PRODUCTOS LOOP    
                INSERT INTO DETALLE VALUES (REGISTRO.COD_HERRAMIENTA,REGISTRO.CANTIDAD,REGISTRO.TOTAL,ID_ARRIENDO);
            END LOOP;
            
            IF VACIAR_CARRO(RUT_U) = TRUE THEN
                BOOL := 'TRUE';
                MESSAGE := 'EL ARRIENDO SE HA REALIZADO EXITOSAMENTE';
                CODIGO_ARRIENDO := ID_ARRIENDO;
            ELSE
                BOOL := 'TRUE';
                MESSAGE := 'EL ARRIENDO SE HA REALIZADO EXITOSAMENTE, PERO FALLÓ LA LIMPIEZA DEL CARRO DE COMPRAS';
                CODIGO_ARRIENDO := ID_ARRIENDO;
            END IF;
        ELSE
            BOOL := 'FALSE';
            MESSAGE := 'UNA O MÁS HERRAMIENTAS DE SU CARRITO YA HAN SIDO ARRENDADAS POR OTRO USUARIO. PRUEBE LIMPIANDO EL CARRO DE ARRIENDOS Y SELECCIONE NUEVAMENTE LAS HERRAMIENTAS';
            CODIGO_ARRIENDO := -1;
        END IF;
        
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'LA FECHA FINAL DEBE SER A LO MENOS EL DÍA SIGUIENTE DE LA FECHA INICIAL';
        CODIGO_ARRIENDO := -1;
        RETURN;
    END IF;
    RETURN;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            BOOL := 'FALSE';
            MESSAGE := 'NO HAY PRODUCTOS EN EL CARRITO';
            CODIGO_ARRIENDO := -1;
            RETURN;
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            CODIGO_ARRIENDO := -1;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION INICIO_SESION(
    RUT_U IN USUARIO.RUT%TYPE,
    PASS_U IN USUARIO.PASS%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ DECLARE
BEGIN
    IF VALIDACION(RUT_U)=TRUE THEN
        IF CHECKUSER(RUT_U)=TRUE THEN
            IF VALIDAR_LOGIN(RUT_U,PASS_U)=TRUE THEN
                BOOL := 'TRUE';
                MESSAGE := 'INICIO DE SESIÓN AUTORIZADO';
            ELSE
                BOOL := 'FALSE';
                MESSAGE := 'LOS DATOS INGRESADOS SON INCORRECTOS';
            END IF;
        ELSE 
            BOOL := 'FALSE';
            MESSAGE := 'EL USUARIO CON RUT: '||RUT_U||' NO EXISTE EN EL SISTEMA';
        END IF;
    ELSE        
        BOOL := 'FALSE';
        MESSAGE := 'EL RUT INGRESADO NO ES VÁLIDO';
    END IF;
    RETURN;
    EXCEPTION
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := 'HA OCURRIDO UN ERROR INTERNO';
            RETURN;
END; 
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION NUEVA_EMPRESA(
    COD_EMP IN EMPRESA.COD_EMPRESA%TYPE,
    NOMBRE_S IN EMPRESA.NOMBRE%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE 
BEGIN
    LOCK TABLE EMPRESA IN ROW EXCLUSIVE MODE;
    INSERT INTO EMPRESA VALUES (COD_EMP,NOMBRE_S);
    BOOL := 'TRUE';
    MESSAGE := 'LA EMPRESA SE HA INGRESADO EXITOSAMENTE';
    RETURN;
    EXCEPTION
	WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
	    MESSAGE := 'NO TIENE PRIVILEGIOS PARA REGISTRAR UNA NUEVA EMPRESA';
            RETURN;
        WHEN unique_violation THEN
            BOOL := 'FALSE';
            MESSAGE := 'LA EMPRESA QUE INTENTA INGRESAR YA SE ENCUENTRA REGISTRADA';         
            RETURN;   
        WHEN OTHERS THEN
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION ELIMINAR_EMPRESA(
    CODIGO IN EMPRESA.COD_EMPRESA%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE
    NOMBRE_EMPRESA VARCHAR(100);
BEGIN
    IF(CHECKEMPRESA(CODIGO)=TRUE) THEN
        SELECT NOMBRE INTO NOMBRE_EMPRESA FROM EMPRESA WHERE COD_EMPRESA = CODIGO;
        LOCK TABLE EMPRESA IN ROW EXCLUSIVE MODE;
        DELETE FROM EMPRESA WHERE COD_EMPRESA=CODIGO;
        
        BOOL := 'TRUE';
        MESSAGE := 'LA EMPRESA: '||NOMBRE_EMPRESA||' HA SIDO ELIMINADA SATISFACTORIAMENTE';
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'LA EMPRESA QUE INTENTA ELIMINAR NO EXISTE EN LA BASE DE DATOS';
    END IF;
    RETURN;
    EXCEPTION
	WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
            MESSAGE := 'NO TIENE PRIVILEGIOS PARA ELIMINAR UNA EMPRESA';
            RETURN;
        WHEN OTHERS THEN
            BOOL:='FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION ACTUALIZAR_EMPRESA(
    COD_EMP IN EMPRESA.COD_EMPRESA%TYPE,
    NOMBRE_S IN EMPRESA.NOMBRE%TYPE,
    BOOL OUT VARCHAR,
    MESSAGE OUT VARCHAR)
RETURNS RECORD AS $$ 
DECLARE
    NOMBRE_EMPRESA VARCHAR(100);
BEGIN
    IF(CHECKEMPRESA(CODIGO_EMP)=TRUE) THEN
        SELECT NOMBRE INTO NOMBRE_EMPRESA FROM EMPRESA WHERE COD_EMPRESA = COD_EMP;
        LOCK TABLE EMPRESA IN ROW EXCLUSIVE MODE;
        UPDATE EMPRESA
        SET NOMBRE=NOMBRE_S
        WHERE COD_EMPRESA=COD_EMP;        
        BOOL := 'TRUE';
        MESSAGE := 'LA ACTUALIZACIÓN DE LA EMPRESA: '||NOMBRE_EMPRESA||' SE HA REALIZADO CON ÉXITO';
    ELSE
        BOOL := 'FALSE';
        MESSAGE := 'NO SE PUDO ACTUALIZAR LA EMPRESA YA QUE NO EXISTE EN LA BASE DE DATOS';
    END IF;
    RETURN;
    EXCEPTION
	WHEN insufficient_privilege THEN
            BOOL := 'FALSE';
            MESSAGE := 'NO TIENE PRIVILEGIOS PARA ACTUALIZAR LA EMPRESA';
            RETURN;
        WHEN OTHERS THEN    
            BOOL := 'FALSE';
            MESSAGE := SQLERRM;
            RETURN;
END;
$$ LANGUAGE PLPGSQL;